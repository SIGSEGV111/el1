io-streams / filter:

	Variante 1 (Fiber/Thread Model):
		- Filter wollen immer passive Inputs/Outputs haben (vereinfacht den Code massiv)
			outstream.Write(...) oder .Put(...)
			instream.Read(...)   oder .Get(...)
			=> ein Fiber oder Threads pro Filter
			=> Buffer müssen ZWISCHEN den einzelnen Filterstufen sein, sodass weniger Task/Fiber-Switches notwendig sind

		- Die Endpunkte sollten sehr schnell sein (inline calls), sodass der Algorithmus sie oft für kleine Datenmengen aufrufen kann
			und keine eigenen Buffer vorhalten muss

		- Inbputs/Outputs sollten blocking sein (vereinfacht den Code)
			=> ein Fiber oder Threads pro Filter
			- Fiber-Switch wenn source Buffer leer oder output Buffer voll
			- genau zu dem Fiber, der diesen Buffer bedienen soll


		- Filter könnten evt. mehrere Inputs und mehrere Outputs haben
			- sehr komplex für den ansteuerenden Code
			=> out of scope?

	Variante 2 (Producer/Consumer Model):
		- Producer ruft seine Consummer auf
		- alles wird via Templates zusammengebaut
		- theoretisch sehr gute performance (Kompiler kann alles optimieren)
		- minimale Buffer
		- Pipeline läuft mit einer festen Aufruf-Richtung (Producer ruft Consumer auf)
			- mehrere Inputs sind nicht möglich?
			- mehrere Outputs sollten recht einfach sein
		- erfordert eine aktive Source und passive Outputs
		- Producer/Consumer-Code ist recht komplex
			- eigenes Buffer/State-Management
